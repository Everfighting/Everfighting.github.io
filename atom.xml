<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thoughts of everfight</title>
  <subtitle>everfight’s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-26T14:16:05.759Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>everfight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记|《图解HTTP》</title>
    <link href="http://yoursite.com/2017/07/26/http-notes/"/>
    <id>http://yoursite.com/2017/07/26/http-notes/</id>
    <published>2017-07-26T14:13:38.000Z</published>
    <updated>2017-07-26T14:16:05.759Z</updated>
    
    <content type="html"><![CDATA[<p>以下是关于《图解HTTP》这本书的笔记。<br><a id="more"></a></p>
<h1 id="第1章-了解Web及网络基础"><a href="#第1章-了解Web及网络基础" class="headerlink" title="第1章 了解Web及网络基础"></a>第1章 了解Web及网络基础</h1><h2 id="1-1-使用HTTP协议访问Web"><a href="#1-1-使用HTTP协议访问Web" class="headerlink" title="1.1 使用HTTP协议访问Web"></a>1.1 使用HTTP协议访问Web</h2><p>HTTP: HyperText Transfer Protocal,超文本传输协议／超文本转移协议。Web是建立在HTTP协议上通信的。</p>
<h2 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h2><p>HTTP于1990年问世，那时候HTTP并没有作为正式的标准被建立，被称为HTTP/0.9<br>HTTP正式作为标准被公布是在1996年5月，版本被命名为HTTP/1.0，该协议至今仍被广泛用在服务器端。<br>HTTP/1.1于1997年1月公布，是目前主流的HTTP协议版本。<br>HTTP/2.0正在制定中。</p>
<h2 id="1-3-网络基础-TCP-IP"><a href="#1-3-网络基础-TCP-IP" class="headerlink" title="1.3 网络基础 TCP/IP"></a>1.3 网络基础 TCP/IP</h2><p>通常使用的网络(包括互联网)是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。我们可以把TCP/IP看成是互联网相关协议的总称。</p>
<p>TCP/IP协议族按层次分别为以下4层：<br>应用层：决定了向用户提供应用服务时的通信活动，该层包括FTP、DNS、HTTP。<br>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，该层包括TCP、UDP。<br>网络层：用来处理在网络上流动的数据包，该层规定了通过怎样的路径达到对方计算机并把数据包传送给对方。<br>数据链路层：用来处理连接网络的硬件部分，如：网卡、光纤。</p>
<p>TCP/IP通信传输流（http举例）<br>（客户端）HTTP客户端–&gt;TCP–&gt;IP–&gt;网络 –|–网络–&gt;IP–&gt;TCP–&gt;HTTP服务器（服务器）<br>发送端每通过一层则增加首部（header），接收端每通过一层则删除首部。这种方法称为封装。</p>
<h2 id="1-4-与HTTP关系密切的协议：IP、TCP和DNS"><a href="#1-4-与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP、TCP和DNS"></a>1.4 与HTTP关系密切的协议：IP、TCP和DNS</h2><p>负责传输的 IP 协议<br>在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<p>确保可靠性的 TCP 协议<br>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h2 id="1-5-负责域名解析的DNS服务"><a href="#1-5-负责域名解析的DNS服务" class="headerlink" title="1.5 负责域名解析的DNS服务"></a>1.5 负责域名解析的DNS服务</h2><p>DNS服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p>
<h2 id="1-6-各种协议与-HTTP-协议的关系"><a href="#1-6-各种协议与-HTTP-协议的关系" class="headerlink" title="1.6 各种协议与 HTTP 协议的关系"></a>1.6 各种协议与 HTTP 协议的关系</h2><p>按流程顺序分别为：<br>DNS服务：把用户输入的域名解析为IP地址<br>HTTP协议：生成针对目标web服务器的HTTP请求报文<br>TCP协议：为了方便通信将HTTP请求报文分割成报文段，把每个报文段可靠的传给对方<br>IP协议：搜索对方的地址，一边中转一边传送<br>TCP协议：从对方那里接收报文段并按序号从组请求报文<br>HTTP协议：对web服务器请求的内容的处理</p>
<h2 id="1-7-URI-和-URL"><a href="#1-7-URI-和-URL" class="headerlink" title="1.7 URI 和 URL"></a>1.7 URI 和 URL</h2><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。URL 是 URI 的子集。<br>区别就是 URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源（既访问资源的方式）。</p>
<h1 id="第2章-简单的http协议"><a href="#第2章-简单的http协议" class="headerlink" title="第2章 简单的http协议"></a>第2章 简单的http协议</h1><h2 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h2><h2 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h2><p>请求报文是由请求方法、请求URI、协议版本、可选的请求头部字段和内容实体构成的。<br>响应报文基本上是由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段及实体主体构成。</p>
<h2 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h2><p>HTTP协议自身不对请求和响应之间的通信状态进行保存。</p>
<h2 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h2><p>HTTP协议使用URI定位互联网上的资源。</p>
<h2 id="2-5-告知服务器意图的http方法"><a href="#2-5-告知服务器意图的http方法" class="headerlink" title="2.5 告知服务器意图的http方法"></a>2.5 告知服务器意图的http方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明    </th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源    </td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件    </td>
</tr>
<tr>
<td>HEAD</td>
<td>获得报文首部</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理    </td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
</tr>
<tr>
<td>UNLINK</td>
<td>断开连接关系</td>
</tr>
</tbody>
</table>
<h2 id="2-6-使用方法下达命令"><a href="#2-6-使用方法下达命令" class="headerlink" title="2.6 使用方法下达命令"></a>2.6 使用方法下达命令</h2><p>向请求URI指定的资源发送请求报文时，采用成为方法的命令。</p>
<h2 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h2><p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端荷载。在HTTP/1.1中所有连接默认都是持久连接。持久连接使得多数请求以管线化方式发送，即能同时并行发送多个请求。</p>
<h2 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h2><p>Ccookie技术是通过在请求和响应报文中写入cookie信息来控制客户端的状态。Cookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端接收到客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h1 id="第3章-HTTP报文内的HTTP信息"><a href="#第3章-HTTP报文内的HTTP信息" class="headerlink" title="第3章 HTTP报文内的HTTP信息"></a>第3章 HTTP报文内的HTTP信息</h1><h2 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h2><p>HTTP报文大致可分为报文首部和报文主体两块，两者有最初出现的空行来划分，通常并不一定要有报文主体。</p>
<h2 id="3-2-请求报文和响应报文的结构"><a href="#3-2-请求报文和响应报文的结构" class="headerlink" title="3.2 请求报文和响应报文的结构"></a>3.2 请求报文和响应报文的结构</h2><p>请求行：包含用于请求的方法，请求URI和HTTP版本<br>状态行：包含响应结果的状态码，原因短语和HTTP版本<br>首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般分别为：通用首部、请求首部、响应首部和实体首部。<br>其他：包含HTTP的RFC里未定义的首部（Cookie等）</p>
<h2 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h2><p>常用的内容编码方式有以下几种：<br>gzip(GNU zip)<br>compress(UNIX系统的标准压缩)<br>deflate(zlib)<br>identity(不进行编码)</p>
<h2 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h2><p>HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。多部分对象集合的每个部分类型中，都可以含有首部字段。</p>
<h2 id="3-5-获取部分内容的范围请求-Range-Request"><a href="#3-5-获取部分内容的范围请求-Range-Request" class="headerlink" title="3.5 获取部分内容的范围请求(Range Request)"></a>3.5 获取部分内容的范围请求(Range Request)</h2><p>执行范围请求时，会用到首部字段Range来指定资源的byte范围。针对范围请求，响应会返回状态码为206 Partial Content的响应报文。</p>
<h2 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如首部字段中的Accept、Accept-Charset、Accept-Enoding、Accept-Language、Content-Language。</p>
<h1 id="第4章-返回结果的HTTP状态码"><a href="#第4章-返回结果的HTTP状态码" class="headerlink" title="第4章 返回结果的HTTP状态码"></a>第4章 返回结果的HTTP状态码</h1><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作已完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
<tr>
<td>2XX</td>
<td>成功</td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>表示从客户端发来的请求在服务器端被正常处理</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>表示服务器接收的请求已成功处理，但返回的响应报文中不允许返回任何实体的主体部分</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>表示客户端进行了范围请求，服务器成功执行了这部分GET请求</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>表示客户端发送附带条件的GET请求时，其访问的资源（自上次访问以来或者根据请求的条件）未变化</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td>Bad Request</td>
<td>表示报文中存在语法错误</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>表示对请求资源的访问被服务器拒绝了</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>表示服务器上无法找到请求的资源</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误</td>
<td></td>
</tr>
<tr>
<td>501</td>
<td>Internet Sever Error</td>
<td>表示服务器端在执行请求时发生了错误</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>表示服务器暂时处于超负荷或正在停机维护，现无法处理请求</td>
</tr>
</tbody>
</table>
<h1 id="第5章-与http协作的web服务器"><a href="#第5章-与http协作的web服务器" class="headerlink" title="第5章 与http协作的web服务器"></a>第5章 与http协作的web服务器</h1><h2 id="5-1-用单个虚拟主机实现多个域名"><a href="#5-1-用单个虚拟主机实现多个域名" class="headerlink" title="5.1 用单个虚拟主机实现多个域名"></a>5.1 用单个虚拟主机实现多个域名</h2><p>HTTP / 1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。这是利用虚拟主机的功能。<br>在互联网上，域名通过 DNS 服务映射到 IP 地址之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，当一台托管了两个域名的服务器接收到请求时就需要弄清楚究竟要访问哪个域名。<br>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>
<h2 id="5-2-通信数据转发程序：代理、网关、隧道"><a href="#5-2-通信数据转发程序：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序：代理、网关、隧道"></a>5.2 通信数据转发程序：代理、网关、隧道</h2><p>代理<br>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理服务器的基本行为接收客户端发送的请求后转发给其他服务器，代理不改变请求URI,转发时需要附加Via首部字段已标记出经过的主机信息。<br>使用代理服务器的理由:利用缓存技术（代理缓存）减少网络带宽的流量,组织内部针对特定网站的访问控制，以获取访问日志为主要目的。<br>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文：<br>缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上<br>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，对 报文内容进行加工的代理被成为非透明代理。</p>
<p>网关<br>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。<br>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</p>
<p>隧道<br>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。<br>隧道本身不会去解析 HTTP 请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h2 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h2><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省通信流量和时间。<br>缓存服务器是代理服务器的一种。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。<br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<p>缓存的有效期限<br>对于缓存服务器和客户端浏览器，当判定缓存过期或客户端要求，会向源服务器确认资源的有效性。若失效，浏览器会再次请求新资源。</p>
<p>客户端的缓存<br>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件。</p>
<h1 id="第6章-HTTP首部"><a href="#第6章-HTTP首部" class="headerlink" title="第6章 HTTP首部"></a>第6章 HTTP首部</h1><h2 id="6-2-HTTP-首部字段"><a href="#6-2-HTTP-首部字段" class="headerlink" title="6.2 HTTP 首部字段"></a>6.2 HTTP 首部字段</h2><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<p>4种HTTP首部字段类型<br>通用首部字段、请求首部字段、响应首部字段、实体首部字段。</p>
<h1 id="第-7-章-确保-Web-安全的-HTTPS"><a href="#第-7-章-确保-Web-安全的-HTTPS" class="headerlink" title="第 7 章 确保 Web 安全的 HTTPS"></a>第 7 章 确保 Web 安全的 HTTPS</h1><h2 id="7-1-HTTP-的缺点"><a href="#7-1-HTTP-的缺点" class="headerlink" title="7.1 HTTP 的缺点"></a>7.1 HTTP 的缺点</h2><p>通信使用明文（不加密），内容可能会被窃听<br>不验证通信方的身份，因此有可能遭遇伪装<br>无法证明报文的完整性，所以有可能已遭篡改</p>
<h2 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS"></a>7.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h2><p>HTTPS是身披SSL外壳的HTTP。通常，HTTP直接和TCP通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。SSL是独立于HTTP的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和Telnet等协议均可配合 SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。<br>SSL 采用一种叫做公开密钥加密的加密处理方式。HTTPS 采用混合加密机制。</p>
<h1 id="第8章-确认访问用户身份的认证"><a href="#第8章-确认访问用户身份的认证" class="headerlink" title="第8章 确认访问用户身份的认证"></a>第8章 确认访问用户身份的认证</h1><p>计算机本身无法判定坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。为了确认是否真的具有访问系统的权限，需要核对信息：<br>密码：只有本人才会知道的字符串信息。<br>动态令牌：仅限本人持有的设备内显示的一次性密码。<br>数字证书：仅限本人（终端）持有的信息。<br>生物认证：指纹和虹膜等本人的生理信息。<br>IC卡等：仅限本人持有的信息。</p>
<p>HTTP/1.1使用的认证方式：<br>BASIC认证<br>DIGEST认证（摘要认证）<br>SSL客户端认证<br>FormBase认证（基于表单认证）<br>基于表单认证</p>
<p>Session管理及Cookie状态管理：<br>步骤1：客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面和用户输入数据的发送。<br>步骤2：服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。<br>步骤3:客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可以通过验证接收到的Session ID识别用户和其认证状态。</p>
<h1 id="第9章-基于HTTP的功能追加协议"><a href="#第9章-基于HTTP的功能追加协议" class="headerlink" title="第9章 基于HTTP的功能追加协议"></a>第9章 基于HTTP的功能追加协议</h1><h2 id="9-2-消除HTTP瓶颈的SPDY"><a href="#9-2-消除HTTP瓶颈的SPDY" class="headerlink" title="9.2 消除HTTP瓶颈的SPDY"></a>9.2 消除HTTP瓶颈的SPDY</h2><p>HTTP的瓶颈：<br>使用HTTP协议探知服务器内容是否更新，就需要频繁的从客户端到服务器端进行确认，如果服务器上没有内容更新，此时就会产生徒劳的通信。主要的缺点有：</p>
<p>一条连接上只能发送一个请求<br>请求只能从客户端开始。客户端不可以接收除响应意外的命令。<br>请求/响应首部未经压缩就发送。首部信息越多延时越大。<br>发送冗长的首部。每次相互发送相同首部造成的浪费较多。<br>可任意选择数据压缩格式。非强制压缩发送。</p>
<p>SPDY的设计与功能<br>SPDY没有完全改写HTTP协议，而是在TCP/IP之间应用层和传输层之间通过新加入会话的形式运作，同时考虑安全性问题，SPDY规定通信中使用SSL。<br>SPDY会以会话层加入，控制对数据的流动，但是还是采用HTTP建立通信连接。因此可照常使用HTTP的GET和PSOT等方法、Cookie以及HTTP报文等。</p>
<h2 id="9-3使用浏览器进行全双工通信的WebSocket"><a href="#9-3使用浏览器进行全双工通信的WebSocket" class="headerlink" title="9.3使用浏览器进行全双工通信的WebSocket"></a>9.3使用浏览器进行全双工通信的WebSocket</h2><p>websocket与web浏览器与web服务器之间全双工通信标准。一旦web浏览器和web服务器之间建立这种联系，之后所有的通信都依靠这个专用的协议进行。通信过程中可以相互发送JSON、XML、HTML或者图片等任意格式的数据。</p>
<h1 id="第10章-构建web内容的技术"><a href="#第10章-构建web内容的技术" class="headerlink" title="第10章 构建web内容的技术"></a>第10章 构建web内容的技术</h1><h2 id="10-1-HTML"><a href="#10-1-HTML" class="headerlink" title="10.1 HTML"></a>10.1 HTML</h2><p>为了发送Web上的超文本而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（tag）</p>
<h2 id="10-2-动态HTML"><a href="#10-2-动态HTML" class="headerlink" title="10.2 动态HTML"></a>10.2 动态HTML</h2><p>指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。动态HTML是通过调用客户端脚本javascript，实现对HTML的web页面的动态改造。利用DOM可指定欲发生动态变化的HTML元素。</p>
<h2 id="10-3-Web应用"><a href="#10-3-Web应用" class="headerlink" title="10.3 Web应用"></a>10.3 Web应用</h2><p>指通过web功能提供的应用程序，如购物网站、搜索引擎等。其中由程序创建的内容称之为动态内容，而事先准备好的内容称之为静态内容。web内容则作用于动态内容之上。</p>
<h2 id="10-4数据发布格式及语言"><a href="#10-4数据发布格式及语言" class="headerlink" title="10.4数据发布格式及语言"></a>10.4数据发布格式及语言</h2><p>   XML（extensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用xml，使得互联网数据共享变得容易。XML和HTML都是从标准通用标记语言SGML简化而成<br>   RSS（简易信息聚合）和Atom都是发布新闻博客日志等更新信息文档格式的总称。两者都用到了XML<br>   JSON是一种以javascript的对象表示法为基础的轻量级数据标记语言，能够处理的数据类型有false/null/true/对象/数组/数字/字符串，这7种类型。</p>
<h1 id="第11章-Web的攻击技术"><a href="#第11章-Web的攻击技术" class="headerlink" title="第11章 Web的攻击技术"></a>第11章 Web的攻击技术</h1><h2 id="11-1针对Web的攻击技术"><a href="#11-1针对Web的攻击技术" class="headerlink" title="11.1针对Web的攻击技术"></a>11.1针对Web的攻击技术</h2><p>在客户端即可篡改请求<br>在WEB应用中从浏览器接收到的HTTP请求的全部内容都可以在客户端自由的变更、篡改。因此web引用可能接收到与预期数据不相同的内容；在HTTP请求报文内加载攻击代码就能对web应用发起对web应用的攻击。</p>
<p>攻击模式分类<br>主动攻击（active attack）主要是攻击者通过直接访问web应用把攻击代码传入的攻击模式。由于该模式是针对服务器上的资源进行攻击，因此攻击者需要能够访问那些资源，主动攻击模式中具有代表性的有SQL注入攻击和OS命令注入攻击。<br>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标web应用访问发起攻击。</p>
<h2 id="11-2因输出值转移不完全引发安全漏洞"><a href="#11-2因输出值转移不完全引发安全漏洞" class="headerlink" title="11.2因输出值转移不完全引发安全漏洞"></a>11.2因输出值转移不完全引发安全漏洞</h2><p>实施web应用对策大致可以分为以下两种：客户端验证、web应用端（服务器端）的验证。</p>
<p>跨站脚本攻击<br>跨站脚本攻击（XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。动态创建的HTML部分可能有隐藏的漏洞，这样攻击者编写脚本陷阱，用户在自己浏览器上运行时，一不小心就会受到被动攻击。</p>
<p>对用户Cookie的窃取攻击<br>通过js脚本窃取Cookie信息</p>
<p>SQL注入攻击<br>SQL注入是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。该安全隐患可能会导致个人信息及机密信息的泄露。由于We应用通常会使用到数据库，如果在调用数据库语句方式存在疏漏，就有可能被执行恶意注入。</p>
<p>OS命令注入攻击<br>OS命令注释系统是指通过web应用执行非法的操作系统命令达到攻击的目的。可以从wen应用中通过shell来调用操作系统命令，倘若调用shell时存在疏漏就可以执行插入的非法OS命令，通过os注入攻击可以执行os上安装着的各种程序。</p>
<p>HTTP首部注入攻击<br>HTTP首部注入攻击是指攻击者通过响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，属于被动式攻击。向首部主体添加内容的攻击方式称为HTTP响应截断攻击</p>
<p>HTTP响应截断攻击<br>HTTP响应截断攻击是HTTP首部注入攻击的一种，攻击顺序相同但是要将%0D%0A%0D%0A并排插入字符串后发送，利用这两个连续换行就可以做出HTTTP首部与主体分割所需的空行了，这样就能显示伪造的主体，达到攻击的目的。这样的攻击称作HTTP响应截断攻击。</p>
<p>邮件首部注入攻击<br>是指web应用中的邮件发送功能。攻击者通过向邮件首部To或者Subject内任意添加非法内容发起的攻击。</p>
<p>目录遍历攻击<br>对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击方式。这种攻击又称路径遍历攻击</p>
<p>远程文件包含漏洞<br>指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取后，就可以运行任意脚本的一种攻击方式。（主要是PHP存在的安全漏洞）</p>
<h2 id="11-3因设置上或设计缺陷引发的安全漏洞"><a href="#11-3因设置上或设计缺陷引发的安全漏洞" class="headerlink" title="11.3因设置上或设计缺陷引发的安全漏洞"></a>11.3因设置上或设计缺陷引发的安全漏洞</h2><p>主要是错误设置web服务器或者是由设计上的一些问题引起的安全漏洞。主要包括下面3个方面</p>
<p>强制浏览<br>强制浏览安全漏洞是指，从安置在web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。强制浏览可以造成诸如泄露顾客的个人信息等重要情报、泄露原本需要具有访问权限的用户才可以查阅的信息内容、泄露未连接到外界的文件</p>
<p>不正确的错误消息处理<br>指web应用的错误小心包含对攻击者有用的信息，包括Web应用抛出的错误消息、数据库等系统抛出的错误消息</p>
<p>开放重定向<br>指对任意URL作重定向跳转的功能。</p>
<h2 id="11-4-因会话管理疏忽引发的安全漏洞"><a href="#11-4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="11.4 因会话管理疏忽引发的安全漏洞"></a>11.4 因会话管理疏忽引发的安全漏洞</h2><p>会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。</p>
<p>会话劫持<br>通过某种非法手段获得用户的ID，并非法使用此会话ID伪装成用户，达到攻击的目的。</p>
<p>会话固定攻击<br>对以窃取目标会话ID为主动攻击手段劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话ID，属于被动攻击</p>
<p>跨站点请求伪造<br>指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或者设定信息等某些状态更新，属于被动攻击</p>
<h2 id="11-5其他安全漏洞"><a href="#11-5其他安全漏洞" class="headerlink" title="11.5其他安全漏洞"></a>11.5其他安全漏洞</h2><p>密码破解攻击<br>点击劫持：指利用透明按钮或者链接做成陷阱，覆盖在Web页面之上，又称页面伪装。<br>dos攻击：是一种让运行中的服务呈现停止状态的攻击，又称服务器停止攻击或拒绝服务攻击。Dos攻击对象不仅限于Web网站还包括网络设备及服务器。主要有两种方式DoS：集中利用访问请求造成资源过载，资源用尽的同时实际服务也就呈现停止状态；通过攻击安全漏洞使服务停止。<br>后门程序：指开发设置的隐藏入口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是关于《图解HTTP》这本书的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
      <category term="notes,read" scheme="http://yoursite.com/tags/notes-read/"/>
    
  </entry>
  
  <entry>
    <title>python web开发笔记一：网页开发基础</title>
    <link href="http://yoursite.com/2017/07/26/python-web-01/"/>
    <id>http://yoursite.com/2017/07/26/python-web-01/</id>
    <published>2017-07-26T13:23:21.000Z</published>
    <updated>2017-07-26T14:10:41.725Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记整理自网易微专业《Python web开发》1.1节 网页开发基础。<br><a id="more"></a></p>
<h1 id="网页基础知识"><a href="#网页基础知识" class="headerlink" title="网页基础知识"></a>网页基础知识</h1><h2 id="网页的构成"><a href="#网页的构成" class="headerlink" title="网页的构成"></a>网页的构成</h2><p>网页由html、css和Javascript构成，html是框架，CSS是样式和装饰，JS则是各项功能实现。我们把网页的组成类比成一栋房子，Html相当于房子的结构，CSS相当于房子的装修装饰，JavaScript相当于房子的水电通信等使用功能。</p>
<h2 id="HTML基础知识"><a href="#HTML基础知识" class="headerlink" title="HTML基础知识"></a>HTML基础知识</h2><p>HTML(Hyper Text Markup Language)：超文本标记语言，通过各种标签来表示网页的骨架。大概有100种以上的标签。</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="常用的标签大概有10种左右。"><a href="#常用的标签大概有10种左右。" class="headerlink" title="常用的标签大概有10种左右。"></a>常用的标签大概有10种左右。</h2><p>如：<br>div标签用于组合其他HTML元素，本身无实在意义。<br>ul, li, ol, dl, dt, dd此类标签用于设置带有列表内容的。<br>form表单相关。<br>table表格相关。<br>img 用于图像显示。<br>a标签用于打开链接。</p>
<h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><p><a href="https://www.zhihu.com/question/19550864" target="_blank" rel="external">id与class的区别</a><br>只有在绝对确定这个元素只会出现一次的情况下，才应该使用Id。如果你认为以后可能需要相似的元素，就使用Class。</p>
<p>样式：<br>    <style><br>    .css5_class{ background:#FFF;} /<em> 背景白色 class用‘.’标记</em>/ </p>
<pre><code>#css5_id{ background:#FF0000;} /* 背景红色 id用‘#’标记*/ 
&lt;/style&gt; 
</code></pre><p>HTML:<br>    <div class="css5_class">我在浏览器下浏览，内容背景将是白色</div><br>    <div id="css5_id">我在浏览器下浏览，内容背景将是红色</div> </p>
<h2 id="标签的嵌套"><a href="#标签的嵌套" class="headerlink" title="标签的嵌套"></a>标签的嵌套</h2><p>网页实际上就是由各类标签嵌套构成，所谓嵌套，就是在成对的标签里加入另一组成对或不成对的标签。外层的标签相对里层的是父级关系，里层相对外层是子级关系。<br>嵌套可以理解成一种逻辑的关系，同样的逻辑关系可以有多种表现样式,好比产品功能流程一致的情况(HTML)，UI设计可以有多个风格(CSS).</p>
<h2 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a><img>标签</h2><p><img> 是一个自闭标签，没有结束</img>。<br>&lt;img src= “1.jpg“ alt=”pic”&gt; src 指 “source”,图像的URL地址,在hmtl同一文件夹下的图片1.jpg，alt是图片的文字描述，在1.jpg无法显示的时候，就会显示pic的文字。在如鼠标放在图片上，会有提示内容，也就是pic.</p>
<h1 id="常见的页面结构"><a href="#常见的页面结构" class="headerlink" title="常见的页面结构"></a>常见的页面结构</h1><p>header（头部：标签栏，导航栏，banner）；<br>content（内容：文章博客，内容列表）；<br>footer（脚部：网站信息，联系方式等）这三部分组成的。</p>
<h1 id="专题研究"><a href="#专题研究" class="headerlink" title="专题研究"></a>专题研究</h1><h2 id="HTML引入CSS样式三种方法及优先级"><a href="#HTML引入CSS样式三种方法及优先级" class="headerlink" title="HTML引入CSS样式三种方法及优先级"></a><a href="http://blog.csdn.net/mybelief321/article/details/50188937">HTML引入CSS样式三种方法及优先级</a></h2><p>css的样式引用由3种方式：内联定义、链入内部CSS和链入外部CSS。<br>三者优先级笔记：内联定义最高、内部CSS次之、外部CSS优先级最低。</p>
<h2 id="块级元素与行内元素"><a href="#块级元素与行内元素" class="headerlink" title="块级元素与行内元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements">块级元素</a>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente">行内元素</a></h2><p>区别：<br>内容上看：一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。<br>格式上看：默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p>
<h2 id="自闭标签"><a href="#自闭标签" class="headerlink" title="自闭标签"></a><a href="http://www.pratikbutani.com/2016/01/list-of-html-self-closing-tags/">自闭标签</a></h2><p>常见的自闭标签有：’’’<br />、<hr />、<img />、<input />、<link />、<meta />‘’’</p>
<h2 id="相对引用和绝对引用"><a href="#相对引用和绝对引用" class="headerlink" title="相对引用和绝对引用"></a><a href="http://write.awthink.net/%E8%87%B4%E7%9F%A5%E5%BD%95/relative-path.html">相对引用和绝对引用</a></h2><p>会判断相对引用的位置及写法。</p>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><h2 id="Atom编辑器快捷键"><a href="#Atom编辑器快捷键" class="headerlink" title="Atom编辑器快捷键"></a>Atom编辑器快捷键</h2><pre><code>ctrl + D   同时修改多个词 
ctrl + \   开启/关闭目录树
ctrl + alt + C   调用颜色插件
ctrl + /   注释
</code></pre><h2 id="补充学习资料"><a href="#补充学习资料" class="headerlink" title="补充学习资料"></a><a href="http://www.w3school.com.cn">补充学习资料</a></h2><h2 id="作业知识点补充"><a href="#作业知识点补充" class="headerlink" title="作业知识点补充"></a>作业知识点补充</h2><p><a href="http://www.adminwang.com/html/34.html"><a>标签的用法</a></p>
<p><a href="http://www.w3school.com.cn/" target="_blank">Visit W3School!</a><br>href参数表示连接转向的地址，可分为内部书签链接和外部网址连接。</p>
<p>内部书签链接：锚<br>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：<br><a name="tips">基本的注意事项 - 有用的提示</a><br>然后，我们在同一个文档中创建指向该锚的链接：<br><a href="#tips">有用的提示</a><br>您也可以在其他页面中创建指向该锚的链接：<br><a href="http://www.w3school.com.cn/html/html_links.asp#tips">有用的提示</a></p>
<p>target参数表示链接打开的方式。</p>
<pre><code>_parent ：在上一级窗口中打开。
_blank：在新窗口中打开。
_self：在同一窗口中打开。（默认）
_top ：在浏览器的整个窗口中打开，忽略任何框架。
</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>该笔记源自网易微专业《Python web开发》1.1节</li>
<li>同学整理<a href="http://naotu.baidu.com/file/b184fa7c015eb669df13901068bd0598?token=1fd2a1b13fd05a9b">Python web开发 1.1节 课程大纲</a> </li>
</ul>
</style></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记整理自网易微专业《Python web开发》1.1节 网页开发基础。&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python web开发笔记三：CSS基础</title>
    <link href="http://yoursite.com/2017/07/26/python-web-03/"/>
    <id>http://yoursite.com/2017/07/26/python-web-03/</id>
    <published>2017-07-26T13:23:21.000Z</published>
    <updated>2017-07-26T13:32:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记源自网易微专业《Python web开发》1.4、1.5、1.6、1.7节<br><a id="more"></a></p>
<h1 id="CSS常用选择器"><a href="#CSS常用选择器" class="headerlink" title="CSS常用选择器"></a>CSS常用选择器</h1><pre><code> - 通配符选择器 *
 - id选择器(id #)
 - 类选择器(class .)
 - 元素选择器(E)
 - 后代选择器(E F)
 - 子元素选择器(E&gt;F)
 - 相邻兄弟元素选择器(E+F)
 - 群组选择器(selector1,selector2,...,selectorN)
 - nth选择器：
fist-child: 选择某个元素的第一个子元素
last-child: 选择某个元素的最后一个子元素
</code></pre><h1 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h1><p>根据样式所在位置：!improtant &gt; 内联样式 &gt; style标签 &gt; link标签。<br>计算方式：</p>
<blockquote>
<p>一个行内样式+1000，一个id+100，一个属性选择器/class或者伪类+10，一个元素名，或者伪元素+1。其他规则见拓展阅读。</p>
</blockquote>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p><img src="http://upload-images.jianshu.io/upload_images/307154-bf1e7c46ec514827.gif?imageMogr2/auto-orient/strip" alt="盒模型"><br>box-sizing:border-box：此时元素的内边距和边框不再会增加它的宽度，更便于理解和计算。</p>
<h1 id="CSS常用属性："><a href="#CSS常用属性：" class="headerlink" title="CSS常用属性："></a>CSS常用属性：</h1><pre><code>- 背景：
background-color：#9cbfcc;
background-repeat: repeat;
background:url(&apos;images/grass.png&apos;);
background-size: contain;（完全限制的设定的大小内部）
- 方位：
padding: 0 20px 30px 0 (上 右 下 左)
margin-right: 10px;
text-align：left;
display:block;(in-line,inline-block)
- 字体：
font-family: 字体
font-size: 大小
- 边框：
border-radius: 圆角半径设置
border: solid 8px rgb(210, 157, 65);  样式，粗细，颜色
</code></pre><h1 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h1><h2 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative(相对定位)"></a>relative(相对定位)</h2><p>设置了相对定位之后，通过修改top,left,bottom,right值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。</p>
<h2 id="absolute-绝对定位-："><a href="#absolute-绝对定位-：" class="headerlink" title="absolute(绝对定位)："></a>absolute(绝对定位)：</h2><p>设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于是它最近的设置了定位属性（position为relative或者absolute，值不为static）的元素。</p>
<h2 id="fixed-固定定位-："><a href="#fixed-固定定位-：" class="headerlink" title="fixed(固定定位)："></a>fixed(固定定位)：</h2><p>设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置。<br>重心修改：<br>transform: translate(-50%,-50%)，坐标原点从左上角改到了中心位置。</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul>
<li><a href="http://flukeout.github.io/" target="_blank" rel="external">选择器小游戏</a></li>
<li><a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html" target="_blank" rel="external">你应该知道的一些事情——CSS权重</a></li>
<li><a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank" rel="external">盒模型详解</a></li>
<li><a href="http://ww3.sinaimg.cn/mw690/c5131475jw1eodf2f2oiaj20c636u1kx.jpg" target="_blank" rel="external">常用CSS属性列表</a></li>
<li><a href="http://www.html-js.com/article/3044" target="_blank" rel="external">absolute与relative</a></li>
<li><a href="http://zh.learnlayout.com" target="_blank" rel="external">学习CSS布局</a></li>
<li><a href="https://stackoverflow.com/questions/9189810/css-display-inline-vs-inline-block#" target="_blank" rel="external">inline-vs-inline-block</a></li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>该笔记源自网易微专业《Python web开发》1.4、1.5、1.6、1.7节</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记源自网易微专业《Python web开发》1.4、1.5、1.6、1.7节&lt;br&gt;
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python web开发笔记二：Semantic UI框架</title>
    <link href="http://yoursite.com/2017/07/26/python-web-02/"/>
    <id>http://yoursite.com/2017/07/26/python-web-02/</id>
    <published>2017-07-26T13:23:21.000Z</published>
    <updated>2017-07-26T13:33:04.712Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记整理自网易微专业《Python web开发》1.2、1.3、1.4节<br><a id="more"></a></p>
<h1 id="CSS框架"><a href="#CSS框架" class="headerlink" title="CSS框架"></a>CSS框架</h1><ul>
<li>What:<br>简单地说，就是一些事先写好的css集合，你只需要给你的html元素加上一些特定的类，就可以快速的得到一些想要的效果。</li>
<li>Why:<br>简单、快速、方便、避免CSS中的各种坑。</li>
<li>Which:<br>Semantic UI是一款语义化的前端开发框架，Semantic是围绕自然交流语言而架构的，这使得开发更加直观、易于理解。</li>
</ul>
<h1 id="Semantic-UI"><a href="#Semantic-UI" class="headerlink" title="Semantic UI"></a>Semantic UI</h1><h2 id="框架特色"><a href="#框架特色" class="headerlink" title="框架特色"></a>框架特色</h2><p>Semantic UI把词语和类看成一个个可以任意组合的概念，使用如：名词/修饰语，文字序列以及诸多的自然语法来定义类名。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><pre><code>- 名词：具体的元素
ui segment
ui button
ui image
ui container
ui divider
ui header
ui label

- 形容词：
very padded：文字的间距靠里
vertical：去掉边框的圆角、阴影和缝隙
inverted：颜色需要反选填充
basic: 处理黑边问题
fixed: 固定位置
Mini Tiny Small Medium Large Big Huge Massive：大小
circular：圆形

- 图标名称：
share icon
wifi icon
</code></pre><h2 id="两种引用方式"><a href="#两种引用方式" class="headerlink" title="两种引用方式"></a>两种引用方式</h2><ul>
<li><p>本地引用</p>
<blockquote>
<p>1.把 Semantic CSS 的文件放到 CSS 文件夹中，记得themes中的fonts和images也要拷贝进来。<br>2.在 html文件的head部分的link中写上：href=”css/semantic.css”<br>如：<link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"></p>
</blockquote>
</li>
<li><p>在线引用</p>
<blockquote>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.4/semantic.css">

</blockquote>
</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ul>
<li><p>Task1: 制作博客标签</p>
<pre><code>ui red right ribbon label  # ui label标签样式 ribbon形状 right方向 
ui inverted blue button # 蓝色边框的按钮
ui inverted  vertical very padded  segment # vertical消除圆角、阴影、缝隙 very padded内容往中间聚拢
ui fixed inverted menu # 固定在某个位置的菜单，具体菜单项用ui item表示
</code></pre></li>
<li><p>Task2: 绘制美国队长盾牌</p>
</li>
</ul>
<div class="ui inverted red circular segment">    #大圆，内嵌红色<br>    <div class="ui circular segment">        #中圆，内嵌白色<br>        <div class="ui inverted red circular segment"> #小圆，内嵌红色<br>            <i class="circular inverted blue big star icon"></i> # 中心圆，圆中嵌有五角星，五角星与圆之间用蓝色填充，星内部白色填充<br>            </div><br>        </div><br>    </div><br>

<h2 id="Semantic-UI网格系统"><a href="#Semantic-UI网格系统" class="headerlink" title="Semantic UI网格系统"></a>Semantic UI网格系统</h2><p>ui grid是Semantic框架中用来进行页面动态布局的工具。<br>主要用法分为两种：定宽网格和定栏网格</p>
<ul>
<li><p>定宽网格：页面一共16栏，明确知道每一块横跨宽度<br>  – ui grid </p>
<pre><code>-- ten wide column
-- six wide column
</code></pre></li>
<li><p>定栏网格：要分为几栏，一般为奇数，偶数可转化为定宽<br>  –ui three column grid</p>
<pre><code>-- column
-- column
-- column
</code></pre></li>
<li><p>嵌套</p>
<pre><code>-- ui three column grid container
    -- column
        -- ui two column grid
        -- column
        -- column
    -- column
    -- column
</code></pre></li>
</ul>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><h2 id="ATOM使用技巧"><a href="#ATOM使用技巧" class="headerlink" title="ATOM使用技巧"></a>ATOM使用技巧</h2><ul>
<li>semantic.css打开的话就可以自动联想内部的组件。</li>
<li>左上角蓝色点表示没有保存。</li>
<li>安装browser-plus插件能够直接在编辑器里面看到显示效果，点击闪电标签实时同步修改的效果。</li>
<li>输入lorem会自动生成被打乱顺序的拉丁字母用于填充。</li>
<li>setting中修改show indent guide可以显示atom的对齐线。</li>
</ul>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><a href="https://segmentfault.com/a/1190000000407283" target="_blank" rel="external">2014 年 15 款最棒的 HTML CSS 框架</a></li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>该笔记源自网易微专业《Python web开发》1.2、1.3、1.4节</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记整理自网易微专业《Python web开发》1.2、1.3、1.4节&lt;br&gt;
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python web开发笔记四：Django开发基础</title>
    <link href="http://yoursite.com/2017/07/26/python-web-04/"/>
    <id>http://yoursite.com/2017/07/26/python-web-04/</id>
    <published>2017-07-26T13:23:21.000Z</published>
    <updated>2017-07-26T14:10:32.816Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记整理自网易微专业《Python web开发》2.1、2.2节。<br><a id="more"></a></p>
<h1 id="Why-Django"><a href="#Why-Django" class="headerlink" title="Why Django"></a>Why Django</h1><p>在一定的时间内，有限的技术情况下，建设一个高质量的网站，Django几乎成了唯一的方案。<br>Django把所有可能性都考虑到了，从这种程度上看复杂就意味着全面，毕竟时间更重要！</p>
<h1 id="Django特点"><a href="#Django特点" class="headerlink" title="Django特点"></a>Django特点</h1><ul>
<li>强大的数据库功能</li>
<li>自带的强大的后台功能</li>
<li>优雅的网址</li>
<li>模板系统</li>
<li>缓存系统</li>
<li>国际化</li>
</ul>
<h1 id="Django应用案例"><a href="#Django应用案例" class="headerlink" title="Django应用案例"></a>Django应用案例</h1><p>国外：Disqus、Pinterest、Instagram、NASA Science等<br>国内：豆瓣、知乎、饿了么等</p>
<p>#Django开发准备<br>1、安装pip<br>2、安装Django<br>3、安装pyflakes<br>4、Atom安装插件：atom-django、autocomplete-python、platformio-ide-terminal(也可以用pycharm)</p>
<h1 id="MTV模型"><a href="#MTV模型" class="headerlink" title="MTV模型"></a>MTV模型</h1><h2 id="网页访问流程："><a href="#网页访问流程：" class="headerlink" title="网页访问流程："></a>网页访问流程：</h2><pre><code>request ----&gt;Django Web------&gt;response
</code></pre><h2 id="流程内部结构："><a href="#流程内部结构：" class="headerlink" title="流程内部结构："></a>流程内部结构：</h2><pre><code>request——————&gt;urls——————&gt;views&lt;——————models
                              |
                              |
                              ↓
                          templates
</code></pre><h2 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h2><p>models—–数据: 作为数据库的代理人，通过 model 操作数据库。<br>Templates—–模板: 把数据填充进网页中进行渲染。<br>Views—–视图:把渲染好的网页返回给使用者，让我们可以在浏览器中看到网页。<br>Urls—–链接：找到每个 url 对应的 view。</p>
<h2 id="为什么要MTV分开？"><a href="#为什么要MTV分开？" class="headerlink" title="为什么要MTV分开？"></a>为什么要MTV分开？</h2><p>复杂的功能，分开可以单独的职责进行处理，快速找到错误，方便处理和维护。</p>
<h1 id="最简单的Django网站："><a href="#最简单的Django网站：" class="headerlink" title="最简单的Django网站："></a>最简单的Django网站：</h1><p>网站创建的流程：P —&gt; A —&gt; D —&gt; M —&gt; V —&gt; T —&gt; U<br>P: 创建project     django-admin startproject firstsite<br>A: 创建APP         python manage.py startapp firstapp<br>D: 创建数据库      python manage.py migrate<br>M: 创建数据库的表  models创建相关模型类class<br>V:  创建视图        views创建相关视图def<br>T: 创建模板        templates/static 用模板语言进行修改<br>U: 创建对应的url正则关系 设置访问url</p>
<h1 id="具体步骤分析"><a href="#具体步骤分析" class="headerlink" title="具体步骤分析"></a>具体步骤分析</h1><h2 id="创建站点："><a href="#创建站点：" class="headerlink" title="创建站点："></a>创建站点：</h2><pre><code>django-admin startproject firstsite
</code></pre><p>生成以下文件：</p>
<pre><code>firstsite
├── manage.py
└── firstsite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
</code></pre><p>文件解释：<br>manage.py：django中命令的运行文件，一般格式为：python manage.py 命令名称。<br><strong>init</strong>.py:是python包的目录结构必须的。<br>setting.py:Django配置全局变量和属性的文件，比如 DEBUG 的开关，静态文件的位置等。<br>urls.py:网址入口，关联到对应的views.py中的一个函数（或者generic类），访问网址就对应一个函数。<br>wsgi.py:部署服务器时用到的wsgi.py文件。</p>
<p>settings内部结构：</p>
<ul>
<li>DEBUG = True时，页面发生错误会直接抛给前台，便于程序员进行修改。在真实环境中需要关闭，DEBUG=False。</li>
<li>当 DEBUG=False 时，ALLOW_HOSTS这个为必填项，如果不想输入，可以用 ALLOW_HOSTS = [‘*’] 来允许所有的访问。</li>
<li>INSTALLED_APPS，用户新建了APP需要在该栏目下进行注册。</li>
<li>TEMPLATES：若新建了templates文件夹，需要修改DIRS地址：<pre><code>&apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;).replace(&apos;\\&apos;, &apos;/&apos;)],
</code></pre></li>
<li><p>DATABASES默认的是:sqlite3, 修改为mysql如下：</p>
<pre><code>DATABASES = {
    &apos;default&apos;: {
        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,
        &apos;NAME&apos;: &apos;testdb&apos;,
        &apos;USER&apos;:&apos;younger&apos;,
        &apos;PASSWORD&apos;:&apos;123&apos;,
        &apos;HOST&apos;:&apos;&apos;,
        &apos;PORT&apos;:&apos;&apos;,
    }
}
</code></pre></li>
<li><p>LANGUAGE_CODE = ‘en-us’, 中文修改为’zh-Hans’。</p>
</li>
</ul>
<h2 id="创建APP"><a href="#创建APP" class="headerlink" title="创建APP"></a>创建APP</h2><p>python manage.py startapp firstapp<br>(项目站点的模块，一个project下面可以有多个app)</p>
<pre><code>生成以下文件：
migrations: 生成数据库的py脚本文件夹。
__init__: 是python包的目录结构必须的。
admin.py：后台，可以用很少量的代码就拥有一个强大的后台。
models.py: 与数据库操作相关，存入或读取数据时用到这个，当然用不到数据库的时候 你可以不使用。
views.py: 处理用户发出的请求，从urls.py中对应过来, 通过渲染templates中的网页可以将显示内容，比如登陆后的用户名，用户请求的数据，输出到网页。
tests.py: 网站的测试代码。
</code></pre><h2 id="添加app到INSTALL-APPS"><a href="#添加app到INSTALL-APPS" class="headerlink" title="添加app到INSTALL_APPS"></a>添加app到INSTALL_APPS</h2><p>新建的app如果不加到INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) 。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code>python mange.py makemigrations
</code></pre><p>makemigrations命令生成的文件会存到migrations/目录下，生成复杂的创建数据库的语句。</p>
<pre><code>python mange.py migrate
</code></pre><p>之前的makemigrations操作只是生成migration文件，还没有对数据库进行操作，接下来执行migrate命令，完成数据的合并和修改。</p>
<pre><code>makemigrations vs migrate
makemigrations的意思是将model编译成mysql可以理解的sql语句，存放在那个migrations文件夹里面。
migrate是将这个最新生成的py文件执行，让数据库能够按照sql语句进行表的修改。由于sql语句中有很多的标点符号是和python冲突的，经常需要转义数据库才能执行。因此直接使用model模块可以省去你很多书写sql语句的烦恼。
</code></pre><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><pre><code>python mange.py runserver 临时测试的服务器
</code></pre><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="views中定义视图"><a href="#views中定义视图" class="headerlink" title="views中定义视图"></a>views中定义视图</h2><pre><code>t = Template(html_string)      # 用来把 html 字符变成模板，类似于打孔。
c = Context({&apos;person&apos;:person}) # 创建一个上下文 context,django 规定 context 必须是字典的形式，类似于造补丁。
web_page = t.render(c)           # 对模板进行渲染，把上下文渲染到模板里面，类似于打补丁。
return HTTPResponse(web_page)  # web_page表示的网页字符串转化具体可见的网页response。
</code></pre><p>拓展阅读：<br>1、<a href="http://everfighting.club/2016/10/09/http-illustration-01/" target="_blank" rel="external">《图解HTTP》笔记</a><br>2、<a href="http://www.ziqiangxuetang.com/django/django-tutorial.html" target="_blank" rel="external">Django 基础教程(自强学堂)</a></p>
<p>备注<br>该笔记源自网易微专业《Python web开发》2.1、2.2节</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记整理自网易微专业《Python web开发》2.1、2.2节。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python web开发笔记五：Django开发进阶</title>
    <link href="http://yoursite.com/2017/07/26/python-web-05/"/>
    <id>http://yoursite.com/2017/07/26/python-web-05/</id>
    <published>2017-07-26T13:23:21.000Z</published>
    <updated>2017-07-26T14:09:22.181Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记源自网易微专业《Python web开发》2.2节<br><a id="more"></a></p>
<h1 id="理解上下文"><a href="#理解上下文" class="headerlink" title="理解上下文"></a>理解上下文</h1><pre><code>render(request,x.html,context)
request:请求的固定写法。
x.html:模板，需要填补丁的模板。
context:上下文,填充模板的补丁。
</code></pre><h1 id="模板的使用流程"><a href="#模板的使用流程" class="headerlink" title="模板的使用流程"></a>模板的使用流程</h1><ul>
<li>写模板，创建Template对象，用模板语言进行修改。</li>
<li>创建Context，context是一组字典，用来传递数据给Template对象。</li>
<li>调用Template对象的render()方法传递context来填充模板。</li>
</ul>
<h1 id="创建并使用模板"><a href="#创建并使用模板" class="headerlink" title="创建并使用模板"></a>创建并使用模板</h1><ul>
<li>单独创建templates、staitc文件夹，将之前写的前端文件如何放入Django项目。</li>
<li>网页放入tempaltes，所有的静态文件放入static中。(静态文件是指网站中的 js, css, 图片，视频等)</li>
<li>修改setting，TEMPLATES，DIRS:[os.path.join(BASE_DIR,’templates’).replace(‘\‘,’/‘)], (注意逗号不能够少)</li>
<li>html最上方加入load staticfiles,在模板中引入静态文件，修改模板中的固定地址改为动态地址。static ‘css/semantic.css’</li>
</ul>
<h1 id="模板语言"><a href="#模板语言" class="headerlink" title="模板语言"></a>模板语言</h1><p>模板语言分为：模板变量，模板标签，模板过滤器。</p>
<pre><code>{% raw %} 
	模板变量:     
		{{ value }},{{ Person.name }}
	模板标签：

		{% for item in list %}
			{{ item }}
		{% endfor %}

		{% for key, value in dict.items %}
			{{ key }}: {{ value }}
		{% endfor %}

		{% if today_is_weekend %}
			<p>Welcome to the weekend!</p>
		{% else %}
			<p>Get back to work.</p>
		{% endif %}

	注：标签可以多重进行嵌套。

	其他：

		{% forloop.first %}是一个布尔值。在第一次执行循环时该变量为True
		{% forloop.last %}是一个布尔值；在最后一次执行循环时被置为True。

	模板过滤器：

		{{ value|default:"nothing" }} 如果为空则显示nothing的样式。
		{{ value|truncatewords:200 }} 只显示前200个字符。
		{{ name|lower }} 功能是转换文本为小写。

	{% endraw %}    
</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>使用 django 的’日期字段’给每篇文章添加类似图中的一个发布日期，格式是「2016-11-05」</p>
<pre><code>model增加:
class Aritcle(models.Model):
    date = models.DateField(auto_now=True)

html增加:

{% raw %}
	<span class="grey">	{{ article.date|date:"Y-m-d" }}</span>
	{% endraw %}
</code></pre><h1 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h1><h2 id="extends标签"><a href="#extends标签" class="headerlink" title="extends标签"></a>extends标签</h2><p>定义一个父模板为base.html,写出HTML的骨架，将需要子块修改的地方用    {% block %}{% endblock %}	标出。<br>子模板使用    {% extends "base.html" %}将内容填写进这些空白的内容块。<br>模板继承允许你建立一个基本的”骨架”模板, 它包含你所有最常用的站点元素并定义了一些可以被子模板覆盖的block。<br>如果你需要在子模板中引用父模板中的 block 的内容,使用{{ block.super }}	 变量.这在你希望在父模板的内容之后添加一些内容时会很有用.(你不必完全覆盖父模板的内容.)</p>
<h2 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h2><pre><code>{% raw %}{% include %}{% endraw %}该标签允许在(模板中)包含其它的模板的内容。
</code></pre><p>标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。<br>每当在多个模板中出现相同的代码时，就应该考虑是否要使用     {% include %}来减少重复。</p>
<ul>
<li>stackoverflow问题：    {% include %} vs {% extends %} in django templates?<blockquote>
<p>Extending allows you to replace blocks (e.g. “content”) from a parent template instead of including parts to build the page (e.g. “header” and “footer”). This allows you to have a single template containing your complete layout and you only “insert” the content of the other template by replacing a block.<br>If the user profile is used on all pages, you’d probably want to put it in your base template which is extended by others or include it into the base template. If you wanted the user profile only on very few pages, you could also include it in those templates. If the user profile is the same except on a few pages, put it in your base template inside a block which can then be replaced in those templates which want a different profile.</p>
</blockquote>
</li>
</ul>
<h2 id="模板注释"><a href="#模板注释" class="headerlink" title="模板注释"></a>模板注释</h2>
注释使用{# #}注释不能跨多行 eg: {# This is a comment #}

<h1 id="urls相关"><a href="#urls相关" class="headerlink" title="urls相关"></a>urls相关</h1><h2 id="urls中定义链接-三种"><a href="#urls中定义链接-三种" class="headerlink" title="urls中定义链接(三种)"></a>urls中定义链接(三种)</h2><pre><code>Function views
Add an import:  from my_app import views
Add a URL to urlpatterns:  url(r&apos;^$&apos;, views.home, name=&apos;home&apos;)

Class-based views
Add an import:  from other_app.views import Home
Add a URL to urlpatterns:  url(r&apos;^$&apos;, Home.as_view(), name=&apos;home&apos;)

Including another URLconf
Import the include() function: from django.conf.urls import url, include
Add a URL to urlpatterns:  url(r&apos;^blog/&apos;, include(&apos;blog.urls&apos;))
</code></pre><h2 id="url的name属性"><a href="#url的name属性" class="headerlink" title="url的name属性"></a>url的name属性</h2><p>url(r’^add/$’, calc_views.add, name=’add’),<br>这里的name可以用于在 templates, models, views ……中得到对应的网址，相当于“给网址取了个名字”，只要这个名字不变，网址变了也能通过名字获取到。</p>
<h2 id="url正则表达式"><a href="#url正则表达式" class="headerlink" title="url正则表达式"></a>url正则表达式</h2><pre><code>url(r&apos;^(?P&lt;year&gt;\d{4})/(?P&lt;month&gt;\d{1,2})/$&apos;,&apos;get_news_list&apos;,name=&quot;news_archive&quot; )
</code></pre><p><year> <month> 在view的参数获得 如：def index(request,year,month)</month></year></p>
<h2 id="url的include用法"><a href="#url的include用法" class="headerlink" title="url的include用法"></a>url的include用法</h2><pre><code>(r&apos;^weblog/&apos;, include(&apos;mysite.blog.urls&apos;)), 
(r&apos;^photos/&apos;, include(&apos;mysite.photos.urls&apos;)),
</code></pre><p>指向include()的正则表达式并不包含一个$(字符串结尾匹配符)。每当Django 遇到include()时，它将截断匹配的URL，并把【剩余】的字符串发往被包含的 URLconf 作进一步处理。 </p>
<h1 id="创建使用后台"><a href="#创建使用后台" class="headerlink" title="创建使用后台"></a>创建使用后台</h1><p>使用django自带的后台，可以可视化管理后台的数据。</p>
<h2 id="创建超级管理员"><a href="#创建超级管理员" class="headerlink" title="创建超级管理员"></a>创建超级管理员</h2><pre><code>python manage.py createsuperuser # 设置用户名，密码。
</code></pre><h2 id="注册自定义model"><a href="#注册自定义model" class="headerlink" title="注册自定义model"></a>注册自定义model</h2><pre><code>from models import People
admin.site.register(People)
</code></pre><h2 id="修改显示字段"><a href="#修改显示字段" class="headerlink" title="修改显示字段"></a>修改显示字段</h2><p>管理后台默认显示People Obejct，在model中添加返回值方法，修改显示效果。</p>
<pre><code>def __str__(self):
    return self.name 
</code></pre><h2 id="修改后台密码的方法"><a href="#修改后台密码的方法" class="headerlink" title="修改后台密码的方法"></a>修改后台密码的方法</h2><pre><code>python manage.py createsuperuser --username admin
python manage.py changepassword admin
</code></pre><h2 id="admin显示自定义字段"><a href="#admin显示自定义字段" class="headerlink" title="admin显示自定义字段"></a>admin显示自定义字段</h2><pre><code>from django.contrib import admin
from .models import Article

class ArticleAdmin(admin.ModelAdmin):
    list_display = (&apos;title&apos;,&apos;pub_date&apos;,&apos;update_time&apos;,)

admin.site.register(Article,ArticleAdmin)
</code></pre><h1 id="引入数据"><a href="#引入数据" class="headerlink" title="引入数据"></a>引入数据</h1><p>Django ORM对数据库进行操作，数据库操作完成之后，记得要进行save()保存。</p>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><pre><code>Article.objects.all() 获取表中所有对象
Aritcle.objects.get(pk=1) # Django中pk=primary key,和id等价。
Article.objects.filter(pub_date__year=2006) # 使用过滤器获取特定对象
Article.objects.all().filter(pub_date__year=2006) #与上方一致

## 链式过滤
&gt;&gt;&gt; Aritcle.objects.filter(
...     headline__startswith=&apos;What&apos;
... ).exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(
...     pub_date__gte=datetime(2005, 1, 30)
... )

Article.objects.create(author=me, title=&apos;Sample title&apos;, text=&apos;Test&apos;) #创建对象
Person.objects.get_or_create(name=&quot;WZT&quot;, age=23) # 防止重复很好的方法

Article.objects.all()[:5] 记录前5条 
Person.objects.all().reverse()[:2] # 最后两条
Person.objects.all().reverse()[0] # 最后一条

&gt;&gt;&gt; Post.objects.filter(title__contains=&apos;title&apos;) # 包含查询
[&lt;Post: Sample title&gt;, &lt;Post: 4th title of post&gt;] 
# 注在title与contains之间有两个下划线字符 (_)。
# Django的ORM使用此语法来分隔字段名称 （&quot;title&quot;） 和操作或筛选器(&quot;contains&quot;)。

Post.objects.order_by(&apos;-created_date&apos;) # 对象进行排序，默认升序，添负号为降序。
Person.objects.filter(name__iexact=&quot;abc&quot;) # 不区分大小写
Person.objects.filter(name__exact=&quot;abc&quot;) # 严格等于

Person.objects.filter(name__regex=&quot;^abc&quot;)  # 正则表达式
Person.objects.filter(name__iregex=&quot;^abc&quot;) # 不区分大小写

Person.objects.exclude(name__contains=&quot;WZ&quot;)  # 排除
Person.objects.filter(name__contains=&quot;abc&quot;).exclude(age=23
 #找出名称含有abc, 但是排除年龄是23岁的
</code></pre><h2 id="QuerySet创建对象的四种方法"><a href="#QuerySet创建对象的四种方法" class="headerlink" title="QuerySet创建对象的四种方法"></a>QuerySet创建对象的四种方法</h2><pre><code>Author.objects.create(name=&quot;WeizhongTu&quot;, email=&quot;tuweizhong@163.com

twz = Author(name=&quot;WeizhongTu&quot;, email=&quot;tuweizhong@163.com&quot;)
twz.save()

twz = Author()
twz.name=&quot;WeizhongTu&quot;
twz.email=&quot;tuweizhong@163.com&quot;

Author.objects.get_or_create(name=&quot;WeizhongTu&quot;, email=&quot;tuweizhon“)
# 返回值(object, True/False)
</code></pre><h2 id="QuerySet是可迭代的"><a href="#QuerySet是可迭代的" class="headerlink" title="QuerySet是可迭代的"></a>QuerySet是可迭代的</h2><pre><code>es = Entry.objects.all()
for e in es:
    print(e.headline)
</code></pre><h2 id="检查对象是否存在"><a href="#检查对象是否存在" class="headerlink" title="检查对象是否存在"></a>检查对象是否存在</h2><pre><code>Entry.objects.all().exists() 返回布尔值
</code></pre><p>拓展阅读：<br><a href="http://o90wo9y16.bkt.clouddn.com/Django%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-%E7%AC%AC%E4%BA%8C%E8%AF%BE.pdf" target="_blank" rel="external">课堂操作内容文档</a></p>
<p>备注<br>该笔记源自网易微专业《Python web开发》2.2节</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记源自网易微专业《Python web开发》2.2节&lt;br&gt;
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>beautiful idiomatic python</title>
    <link href="http://yoursite.com/2017/07/23/beautiful_idiomatic_python/"/>
    <id>http://yoursite.com/2017/07/23/beautiful_idiomatic_python/</id>
    <published>2017-07-23T15:30:49.000Z</published>
    <updated>2017-07-24T01:49:48.072Z</updated>
    
    <content type="html"><![CDATA[<p>Created by JeffPaine<br><script src="//gist.github.com/6213790.js"></script></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Created by JeffPaine&lt;br&gt;&lt;script src=&quot;//gist.github.com/6213790.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="PyCon" scheme="http://yoursite.com/tags/PyCon/"/>
    
  </entry>
  
  <entry>
    <title>最美好关系大概就是彼此驯化了</title>
    <link href="http://yoursite.com/2017/07/23/spoil/"/>
    <id>http://yoursite.com/2017/07/23/spoil/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-07-23T06:11:28.227Z</updated>
    
    <content type="html"><![CDATA[<p>早上出门坐电梯时，常常能碰到楼上王阿姨和她的女儿阿花。记得初见阿花时，她很害羞，只是偷偷的瞄我。后来熟络了，我每次见到她，都会喊她的名字。她听到我喊她也刻欢快起来，亲昵的绕在我身边，而我心中也升起一丝暖暖的幸福。<br><a id="more"></a><br>后来读到《人类简史》才知道这叫做彼此驯化。阿花的祖先一万多年前就已经是人类的好伙伴了。现在，她们忠心耿耿的守护着人类，人类也勤勤恳恳甘愿为奴。《小王子》中狐狸对小王子说：“你要永远为你驯化的东西负责。你要为你的玫瑰负责。” 狐狸被小王子驯化了，于她而言，王子是独一无二的，但是她还是选择了放手，看似最后什么好处都没得到，.她却说那是眼睛看不到的好处。</p>
<p>上周回了趟闵大荒，见了几个老友。发现她们的恋爱状态也类似于彼此驯化。赵博士吐槽大明同学想找一个瘦瘦的男友，最后找了个胖胖的。大明同学也挖苦赵博士想不开，竟然看上六爷。而对于主页妞，她们俩都感觉惋惜，认为她配得上更好的。在我看来，虽然每天都要开冗长的“电话会议”，接受时不时的“查岗”，但是她们脸上洋溢着幸福的微笑。</p>
<p>那天下午跟赵博士去买烧烤的肉串，跟她打探六爷，理性汉子的赵博士竟也陷入了痴痴傻傻的状态，娇羞的说不想跟我扯淡。晚上主页妞男友来，进门一个摸头杀，堂堂院主席就被降服了。还记的上月老大跟玲姐讨论问题，玲姐问，你为什么一直看着我的电脑啊！老大说，不看你的电脑，难道看你么？ 一脸的宠溺，好生令人羡慕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早上出门坐电梯时，常常能碰到楼上王阿姨和她的女儿阿花。记得初见阿花时，她很害羞，只是偷偷的瞄我。后来熟络了，我每次见到她，都会喊她的名字。她听到我喊她也刻欢快起来，亲昵的绕在我身边，而我心中也升起一丝暖暖的幸福。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/categories/Life/"/>
    
    
      <category term="love" scheme="http://yoursite.com/tags/love/"/>
    
  </entry>
  
  <entry>
    <title>7、8月技术成长计划</title>
    <link href="http://yoursite.com/2017/07/13/first-blog/"/>
    <id>http://yoursite.com/2017/07/13/first-blog/</id>
    <published>2017-07-13T05:07:56.000Z</published>
    <updated>2017-07-14T06:47:51.216Z</updated>
    
    <content type="html"><![CDATA[<p>这次博客找回的第一篇文档。<br><a id="more"></a><br>7、8月需研究主题：python基础语法、sql语法、git操作。<br>python基础语法：<br>书籍:《Python学习手册》、《基础教程》、《核心编程》<br>博客文章：《常见算法实现》、《1000行快速了解Python》<br>网络教程：廖雪峰 Python3教程<br>视频教程：慕课网配套廖雪峰教程</p>
<p>git操作：<br>书籍:《Pro Git》、《Git权威指南》<br>网络教程：廖雪峰 Git教程<br>训练教程：实验楼《Git实战教程》</p>
<p>SQL语法：<br>书籍：《SQL必知必会》、《SQL学习手册》<br>训练教程：SQLZOO训练题</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次博客找回的第一篇文档。&lt;br&gt;
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
      <category term="plan" scheme="http://yoursite.com/tags/plan/"/>
    
  </entry>
  
</feed>
